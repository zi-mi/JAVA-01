GC策略演示
演示jdk版本：jdk1.8.0_231
演示类：GCLogAnalysis.java
1、Serial GC
串行GC是一个单线程的垃圾收集器，在年轻代使用的标记-复制算法，在老年代用的是标记-清除-整理算法；在进行GC时必须暂停所有的工作线程，直至GC结束；因为是单线程，其cup利用率高，但STW的时间长。串行GC策略适用于单核服务器的小型应用。

2、Parallel GC
并行GC采用的是多线程来扫描并压缩堆，因此STW的停顿时间短，垃圾收集效率高，吞吐量更高。和串行GC一样，在年轻代使用的是标记-复制算法，在老年代用的是标记-清除-整理算法。并行GC适用于比较大型的应用，对多核服务器更为适用。

3、CMS GC
CMS GC是主要针对年老代的回收，目标是尽量减少应用的暂停时间，减少Full GC发生的几率。CMS GC时会有两次短暂的STW，这样有效的避免了串行标记整理算法的长暂停。CMS GC的周期如下：
阶段 1: Initial Mark（初始标记） 
阶段 2: Concurrent Mark（并发标记） 
阶段 3: Concurrent Preclean（并发预清理） 
阶段 4: Final Remark（最终标记） 
阶段 5: Concurrent Sweep（并发清除） 
阶段 6: Concurrent Reset（并发重置）。
其中的1，4两个步骤需要暂停所有的应用程序线程的。第一次暂停从root对象开始标记存活的对象，这个阶段称为初始标记；第二次暂停是在最终标记， 暂停所有应用程序线程，重新标记并发标记阶段遗漏的对象（在并发标记阶段结束后对象状态的更新导致）。第一次暂停会比较短，第二次暂停通常会比较长，并且 remark这个阶段可以并行标记。而并发标记、并发清除、并发重设阶段的所谓并发，是指一个或者多个垃圾回收线程和应用程序线程并发地运行，垃圾回收线程不会暂停应用程序的执行，如果你有多于一个处理器，那么并发收集线程将与应用线程在不同的处理器上运行，显然，这样的开销就是会降低应用的吞吐量。Remark阶段的并行，是指暂停了所有应用程序后，启动一定数目的垃圾回收进程进行并行标记，此时的应用线程是暂停的。
CMS的young generation的回收采用的仍然是并行复制收集器，这个跟Paralle gc算法是一致的。

4、G1 GC
G1秉持的是垃圾优先的原则，发现哪块区域垃圾最多就会优先进行清理。 G1 GC 避免了CMS的垃圾碎片，
在超大堆上的表现更出色。因为可预测的停顿模型，G1 GC 可以看作一款软实时垃圾收集器。G1里面的Region的概念不同于传统的垃圾回收算法中的分区的概念。
G1的一个特点是把堆内存划分为多个小块堆区（smaller heap regions)），是以Region为单位来进行垃圾收的。Region是实现G1算法的基础，每个Region的大小相等，通过-XX:G1HeapRegionSize参数可以设置Region的大小。各个区域逻辑上并不是连续的。并且一个Region在某一个时刻是Eden，在另一个时刻就可能属于老年代。G1在进行垃圾清理的时候就是将一个Region的对象拷贝到另外一个Region中。
G1另一突出特点是通过一个停顿预测模型来根据用户配置的停顿时间来选择Collection Set(CSet)的大小，从而能够对应用程序暂停时间进行预测。通过-XX:MaxGCPauseMillis参数来设置。但是停顿时间的设置并不是越短越好。设置的时间越短意味着每次收集的CSet越小，导致垃圾逐步积累变多，最终不得不退化成Serial GC；停顿时间设置的过长，那么会导致每次都会产生长时间的停顿，影响了程序对外的响应时间。
从JDK 9开始，G1成为默认的垃圾回收器。G1满足短时间停顿，同时也能达到一个高的吞吐量。适用于多核处理器、大内存容量的服务端系统。 

5、堆内存总结分析：
堆内存分为年轻代和老年代。在年轻代中分出了三个区，分别是eden区、survivor(from)和survivor(to)，这三个区的默认比例为8：1：1。一开始新建的对象一般都会存放到eden区，在经过首次YoungGC之后，尚且活跃的对象会被存放到survivor(from)区中。再接下来的YoungGC时，活跃的对象会被复制到survivor(to)区；而之前存放在survivor(from)区中的对象会根据其活跃状态和时长决定是否提升移动至老年代中，没有提升至老年代的活跃对象会被复制到survivor(to)区中，而此时survivor(to)和survivor(from)的角色会进行交换，to转换成from，from转换为to。这两个survivor区的角色互换会在每次YoungGC时持续进行。当年轻代中对象在经过多次YoungGC后，活跃的对象如果越来越多，随着时间的推移就会有更多的对象提升至老年代，当老年代的内存空间不足的话就会触发FullGC。
在演练GC过程中发现，堆设置的太小容易产生OOM，但是设置堆内存太大了，gc的性能也会受到挺大影响。所以堆内存配置并不是越大越好，也不能设置得太小，应当根据实际的应用场景进行合理分配，尽可能的让内存资源的配置方案往最优方案靠近。
在演练各个GC的过程中，发现如果只是设置-Xmx，不设置-Xms，程序性能会下降很明显；原因是堆内存的初始值设置和最大堆内存设置不相同，这样会造成推空间不断的收缩与扩张。因此，为了避免堆空间不断的收缩与扩张，造成不必要的系统压力。建议在生产环境中，JVM的Xms和Xmx要设置成一样的，这样就能够避免GC在调整堆大小带来的不必要的压力。